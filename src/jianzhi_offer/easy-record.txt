 //剑指 Offer 03. 数组中重复的数字
 找出数组中重复的数字。
 思路：hashset




//剑指 Offer 05. 替换空格
请实现一个函数，把字符串 s 中的每个空格替换成"%20"。
思路：新建一个字符串实现。 时间空间复杂度都为O(N),可用StringBuilder


//剑指 Offer 06. 从尾到头打印链表
输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
思路：用辅助函数获取链表的大小创造数组，并从后往前插入链表内的数字




//剑指 Offer 09. 用两个栈实现队列
用两个stack(FILO)实现一个queue(FIFO)的 appendTail 和 deleteHead
思路：用两个stack，一个用来添加tail，一个用来把顶上要删除的元素pop出去

//剑指 Offer 11. 旋转数组的最小数字
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。
例如，数组[3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。
思路：使用二分查找法（注意此数组为已排序数组，所以旋转之后定为递增序列）


//剑指 Offer 24. 反转链表
定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
思路：在遍历链表时，将当前节点的 next 指针改为指向前一个节点。
    由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。
    在更改引用之前，还需要存储后一个节点。最后返回新的头引用。




//剑指 Offer 30. 包含min函数的栈
定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数
在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
思路：普通栈的 push() 和 pop() 函数的复杂度为 O(1) ；而获取栈最小值 min() 函数需要遍历整个栈，复杂度为 O(N) 。
    所以本题难点在于建立辅助栈，实现在O(1)时间内调用min( )

//剑指 Offer 50. 第一个只出现一次的字符
在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。
思路：hashMap， linkedHashMap


 //剑指 Offer 53 - I. 在排序数组中查找数字 I
 统计一个数字在排序数组中出现的次数。
 思路：遍历，时间复杂度为O(n)
        二分查找，时间复杂度为O(log(n))

//剑指 Offer 53 - II. 0～n-1中缺失的数字
一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。
在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。
思路：已排序好的数组，二分again


//剑指 Offer 58 - II. 左旋转字符串
字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。
思路：可用substring，可用取余简化代码
for(int i = n; i < n + s.length(); i++)
    res.append(s.charAt(i % s.length()));

